# Phase 04: 재고 관리 및 HQ→지사 이전

**작업 기간**: 1주 (5일)
**담당자**: 개발팀
**목표**: HQ에서 지사로 재고 이전, FIFO 로직 구현, 재고 조회 UI

---

## 1. 개요

HQ에 입고된 제품을 베트남/중국 지사로 이전하는 기능을 구현합니다. FIFO(First In, First Out) 로직을 적용하여 유통기한이 가장 빠른 배치부터 출고합니다.

### 핵심 목표
- ✅ 재고 조회 UI (HQ 및 지사별)
- ✅ HQ → 지사 이전 UI
- ✅ **FIFO 로직 구현** (유통기한 순서대로 출고)
- ✅ 재고 이전 시 트랜잭션 처리 (HQ 감소 + 지사 증가)
- ✅ 역할별 재고 조회 권한 (HQ Admin / Branch Manager)

---

## 2. 비즈니스 워크플로우

### 2.1 전체 프로세스

```
1. HQ 재고 조회
   - 제품별, 배치별 재고 현황
   - 유통기한 순 정렬
   ↓
2. 이전 요청 생성
   - 목적지 지사 선택 (Vietnam/China)
   - 제품 및 수량 입력
   ↓
3. FIFO 로직 적용
   - HQ stock_batches에서 가장 빠른 expiry_date 조회
   - 순차적으로 재고 차감
   - 여러 배치에 걸칠 수 있음
   ↓
4. 지사 재고 증가
   - 지사 stock_batches에 동일 배치 추가 또는 업데이트
   ↓
5. 완료
   - HQ 재고 감소
   - 지사 재고 증가
```

---

## 3. FIFO 로직 설계

### 3.1 FIFO 알고리즘

```typescript
// FIFO 로직 예시
function deductStockFIFO(locationId, productId, requestedQty) {
  // 1. 해당 제품의 재고 배치 조회 (유통기한 빠른 순)
  const batches = SELECT * FROM stock_batches
    WHERE location_id = locationId
      AND product_id = productId
      AND qty_on_hand > 0
      AND quality_status = 'OK'
    ORDER BY expiry_date ASC

  // 2. 순차적으로 차감
  let remainingQty = requestedQty
  const deductions = []

  for (const batch of batches) {
    if (remainingQty <= 0) break

    const deductQty = Math.min(batch.qty_on_hand, remainingQty)

    deductions.push({
      batch_id: batch.id,
      batch_no: batch.batch_no,
      deduct_qty: deductQty,
      unit_cost: batch.unit_cost,
      manufactured_date: batch.manufactured_date,
      expiry_date: batch.expiry_date,
    })

    remainingQty -= deductQty
  }

  // 3. 재고 부족 체크
  if (remainingQty > 0) {
    throw new Error('Insufficient stock')
  }

  return deductions
}
```

---

## 4. 작업 상세

### 4.1 재고 조회 UI

#### 4.1.1 재고 목록 페이지

**파일**: `app/(dashboard)/inventory/page.tsx`

```typescript
import { createServerClient } from '@/lib/supabase/server'
import { InventoryList } from '@/components/inventory/inventory-list'
import { Button } from '@/components/ui/button'
import Link from 'next/link'
import { ArrowRightLeft } from 'lucide-react'

export default async function InventoryPage() {
  const supabase = createServerClient()

  // 현재 사용자 정보 조회
  const { data: { user } } = await supabase.auth.getUser()
  const { data: profile } = await supabase
    .from('users')
    .select('role, location_id')
    .eq('id', user?.id)
    .single()

  // 재고 조회 (역할별 필터링)
  let query = supabase
    .from('stock_batches')
    .select(`
      *,
      product:products(sku, name, unit),
      location:locations(name, location_type, currency)
    `)
    .gt('qty_on_hand', 0)
    .order('expiry_date', { ascending: true })

  // Branch Manager는 자기 지사만 조회
  if (profile?.role === 'Branch_Manager') {
    query = query.eq('location_id', profile.location_id)
  }

  const { data: inventory, error } = await query

  if (error) {
    return <div>Error loading inventory: {error.message}</div>
  }

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold">Inventory</h1>
        {profile?.role === 'HQ_Admin' && (
          <Link href="/inventory/transfer">
            <Button>
              <ArrowRightLeft className="mr-2 h-4 w-4" />
              Transfer Stock
            </Button>
          </Link>
        )}
      </div>

      <InventoryList inventory={inventory || []} />
    </div>
  )
}
```

#### 4.1.2 재고 목록 컴포넌트

**파일**: `components/inventory/inventory-list.tsx`

```typescript
'use client'

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table'
import { Badge } from '@/components/ui/badge'
import { formatDate } from '@/lib/utils'

export function InventoryList({ inventory }: { inventory: any[] }) {
  const getExpiryWarning = (expiryDate: string) => {
    const today = new Date()
    const expiry = new Date(expiryDate)
    const daysUntilExpiry = Math.floor((expiry.getTime() - today.getTime()) / (1000 * 60 * 60 * 24))

    if (daysUntilExpiry < 30) {
      return <Badge variant="destructive">Expires in {daysUntilExpiry} days</Badge>
    } else if (daysUntilExpiry < 90) {
      return <Badge variant="warning">Expires in {daysUntilExpiry} days</Badge>
    } else if (daysUntilExpiry < 180) {
      return <Badge variant="secondary">Expires in {daysUntilExpiry} days</Badge>
    }
    return null
  }

  // 지사별로 그룹화
  const groupedInventory = inventory.reduce((acc, item) => {
    const locationName = item.location.name
    if (!acc[locationName]) {
      acc[locationName] = []
    }
    acc[locationName].push(item)
    return acc
  }, {} as Record<string, any[]>)

  return (
    <div className="space-y-6">
      {Object.entries(groupedInventory).map(([locationName, items]) => (
        <div key={locationName}>
          <h2 className="text-xl font-semibold mb-4">{locationName}</h2>
          <div className="border rounded-lg">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Product</TableHead>
                  <TableHead>Batch No.</TableHead>
                  <TableHead>Quantity</TableHead>
                  <TableHead>Manufactured Date</TableHead>
                  <TableHead>Expiry Date</TableHead>
                  <TableHead>Status</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {items.map((item) => (
                  <TableRow key={item.id}>
                    <TableCell>
                      <div>
                        <div className="font-medium">{item.product.sku}</div>
                        <div className="text-sm text-gray-500">{item.product.name}</div>
                      </div>
                    </TableCell>
                    <TableCell>{item.batch_no}</TableCell>
                    <TableCell>
                      {item.qty_on_hand} {item.product.unit}
                    </TableCell>
                    <TableCell>{formatDate(item.manufactured_date)}</TableCell>
                    <TableCell>{formatDate(item.expiry_date)}</TableCell>
                    <TableCell>{getExpiryWarning(item.expiry_date)}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
        </div>
      ))}
    </div>
  )
}
```

---

### 4.2 재고 이전 UI

#### 4.2.1 이전 페이지

**파일**: `app/(dashboard)/inventory/transfer/page.tsx`

```typescript
import { createServerClient } from '@/lib/supabase/server'
import { TransferForm } from '@/components/inventory/transfer-form'

export default async function TransferPage() {
  const supabase = createServerClient()

  // HQ 지사 ID 조회
  const { data: hqLocation } = await supabase
    .from('locations')
    .select('id')
    .eq('location_type', 'HQ')
    .single()

  // 목적지 지사 목록 (Branch만)
  const { data: branches } = await supabase
    .from('locations')
    .select('id, name, country_code')
    .eq('location_type', 'Branch')
    .order('name')

  // 제품 목록
  const { data: products } = await supabase
    .from('products')
    .select('id, sku, name, unit')
    .order('sku')

  return (
    <div>
      <h1 className="text-3xl font-bold mb-6">Transfer Stock</h1>
      <TransferForm
        hqLocationId={hqLocation?.id || ''}
        branches={branches || []}
        products={products || []}
      />
    </div>
  )
}
```

#### 4.2.2 이전 폼 컴포넌트

**파일**: `components/inventory/transfer-form.tsx`

```typescript
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { createClient } from '@/lib/supabase/client'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { useToast } from '@/components/ui/use-toast'

interface TransferFormProps {
  hqLocationId: string
  branches: Array<{ id: string; name: string; country_code: string }>
  products: Array<{ id: string; sku: string; name: string; unit: string }>
}

export function TransferForm({ hqLocationId, branches, products }: TransferFormProps) {
  const [formData, setFormData] = useState({
    to_location_id: '',
    product_id: '',
    qty: 1,
  })
  const [availableStock, setAvailableStock] = useState<number | null>(null)
  const [loading, setLoading] = useState(false)
  const router = useRouter()
  const { toast } = useToast()
  const supabase = createClient()

  // 재고 확인
  const checkAvailableStock = async (productId: string) => {
    const { data } = await supabase
      .rpc('get_available_stock', {
        p_location_id: hqLocationId,
        p_product_id: productId,
      })

    setAvailableStock(data || 0)
  }

  const handleProductChange = (productId: string) => {
    setFormData({ ...formData, product_id: productId })
    checkAvailableStock(productId)
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    if (!formData.to_location_id || !formData.product_id || formData.qty <= 0) {
      toast({ variant: 'destructive', title: 'Please fill all fields correctly' })
      return
    }

    if (availableStock !== null && formData.qty > availableStock) {
      toast({ variant: 'destructive', title: 'Insufficient stock at HQ' })
      return
    }

    setLoading(true)

    try {
      const response = await fetch('/api/inventory/transfer', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          from_location_id: hqLocationId,
          to_location_id: formData.to_location_id,
          product_id: formData.product_id,
          qty: formData.qty,
        }),
      })

      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || 'Transfer failed')
      }

      toast({ title: 'Stock transferred successfully' })
      router.push('/inventory')
      router.refresh()
    } catch (error: any) {
      toast({
        variant: 'destructive',
        title: 'Error',
        description: error.message,
      })
    } finally {
      setLoading(false)
    }
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Transfer from HQ to Branch</CardTitle>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <Label htmlFor="to_location_id">Destination Branch *</Label>
            <Select
              value={formData.to_location_id}
              onValueChange={(value) => setFormData({ ...formData, to_location_id: value })}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select branch" />
              </SelectTrigger>
              <SelectContent>
                {branches.map((branch) => (
                  <SelectItem key={branch.id} value={branch.id}>
                    {branch.name} ({branch.country_code})
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div>
            <Label htmlFor="product_id">Product *</Label>
            <Select
              value={formData.product_id}
              onValueChange={handleProductChange}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select product" />
              </SelectTrigger>
              <SelectContent>
                {products.map((product) => (
                  <SelectItem key={product.id} value={product.id}>
                    {product.sku} - {product.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            {availableStock !== null && (
              <p className="text-sm text-gray-600 mt-1">
                Available at HQ: {availableStock} units
              </p>
            )}
          </div>

          <div>
            <Label htmlFor="qty">Quantity *</Label>
            <Input
              id="qty"
              type="number"
              min="1"
              max={availableStock || undefined}
              value={formData.qty}
              onChange={(e) => setFormData({ ...formData, qty: parseInt(e.target.value) })}
              required
            />
          </div>

          <div className="flex gap-2">
            <Button type="submit" disabled={loading}>
              {loading ? 'Transferring...' : 'Transfer Stock'}
            </Button>
            <Button type="button" variant="outline" onClick={() => router.back()}>
              Cancel
            </Button>
          </div>
        </form>
      </CardContent>
    </Card>
  )
}
```

---

### 4.3 이전 API Route (FIFO 로직 포함)

#### 4.3.1 이전 API

**파일**: `app/api/inventory/transfer/route.ts`

```typescript
import { createServerClient } from '@/lib/supabase/server'
import { NextResponse } from 'next/server'

export async function POST(request: Request) {
  const supabase = createServerClient()

  const { from_location_id, to_location_id, product_id, qty } = await request.json()

  try {
    // 1. FIFO로 HQ 재고 조회 (유통기한 빠른 순)
    const { data: hqBatches, error: fetchError } = await supabase
      .from('stock_batches')
      .select('*')
      .eq('location_id', from_location_id)
      .eq('product_id', product_id)
      .eq('quality_status', 'OK')
      .gt('qty_on_hand', 0)
      .order('expiry_date', { ascending: true })

    if (fetchError) throw fetchError

    if (!hqBatches || hqBatches.length === 0) {
      return NextResponse.json({ error: 'No stock available at HQ' }, { status: 400 })
    }

    // 2. FIFO 로직: 순차적으로 차감
    let remainingQty = qty
    const deductions: Array<{
      batch_id: string
      batch_no: string
      deduct_qty: number
      unit_cost: number
      manufactured_date: string
      expiry_date: string
    }> = []

    for (const batch of hqBatches) {
      if (remainingQty <= 0) break

      const deductQty = Math.min(batch.qty_on_hand, remainingQty)

      deductions.push({
        batch_id: batch.id,
        batch_no: batch.batch_no,
        deduct_qty: deductQty,
        unit_cost: batch.unit_cost,
        manufactured_date: batch.manufactured_date,
        expiry_date: batch.expiry_date,
      })

      remainingQty -= deductQty
    }

    // 3. 재고 부족 체크
    if (remainingQty > 0) {
      return NextResponse.json(
        { error: `Insufficient stock. Short by ${remainingQty} units.` },
        { status: 400 }
      )
    }

    // 4. HQ 재고 차감
    for (const deduction of deductions) {
      const { error: updateError } = await supabase
        .from('stock_batches')
        .update({
          qty_on_hand: supabase.raw(`qty_on_hand - ${deduction.deduct_qty}`),
        })
        .eq('id', deduction.batch_id)

      if (updateError) throw updateError
    }

    // 5. 지사 재고 증가
    for (const deduction of deductions) {
      // 동일 배치가 지사에 이미 있는지 확인
      const { data: existingBatch } = await supabase
        .from('stock_batches')
        .select('id, qty_on_hand')
        .eq('location_id', to_location_id)
        .eq('product_id', product_id)
        .eq('batch_no', deduction.batch_no)
        .single()

      if (existingBatch) {
        // 기존 배치 업데이트
        const { error: updateError } = await supabase
          .from('stock_batches')
          .update({
            qty_on_hand: existingBatch.qty_on_hand + deduction.deduct_qty,
          })
          .eq('id', existingBatch.id)

        if (updateError) throw updateError
      } else {
        // 새 배치 생성
        const { error: insertError } = await supabase
          .from('stock_batches')
          .insert([{
            product_id,
            location_id: to_location_id,
            batch_no: deduction.batch_no,
            qty_on_hand: deduction.deduct_qty,
            qty_reserved: 0,
            unit_cost: deduction.unit_cost,
            manufactured_date: deduction.manufactured_date,
            expiry_date: deduction.expiry_date,
            quality_status: 'OK',
          }])

        if (insertError) throw insertError
      }
    }

    return NextResponse.json({ success: true, deductions })
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}
```

---

### 4.4 PostgreSQL 함수 (재고 조회)

**Supabase SQL Editor에서 실행**:

```sql
-- 특정 지사, 특정 제품의 사용 가능한 총 재고 조회
CREATE OR REPLACE FUNCTION get_available_stock(
  p_location_id UUID,
  p_product_id UUID
)
RETURNS INTEGER AS $$
BEGIN
  RETURN (
    SELECT COALESCE(SUM(qty_available), 0)::INTEGER
    FROM stock_batches
    WHERE location_id = p_location_id
      AND product_id = p_product_id
      AND quality_status = 'OK'
  );
END;
$$ LANGUAGE plpgsql;
```

---

## 5. 테스트 체크리스트

### 5.1 재고 조회 테스트
- [ ] HQ Admin은 모든 지사 재고 조회 가능
- [ ] Branch Manager는 자기 지사 재고만 조회 가능
- [ ] 재고가 유통기한 순으로 정렬됨
- [ ] 유통기한 경고 배지 표시 (1개월/3개월/6개월 이내)
- [ ] 지사별 그룹화 표시

### 5.2 재고 이전 테스트
- [ ] HQ에서 지사로 이전 요청 가능
- [ ] 사용 가능한 재고 수량 표시
- [ ] 재고 부족 시 에러 메시지
- [ ] FIFO 로직 정상 작동 (가장 빠른 유통기한부터 차감)
- [ ] 여러 배치에 걸친 이전 정상 작동
- [ ] HQ 재고 감소 확인
- [ ] 지사 재고 증가 확인
- [ ] 배치 정보 (batch_no, expiry_date) 유지됨

### 5.3 FIFO 검증
- [ ] 유통기한이 빠른 배치부터 차감됨
- [ ] 하나의 배치로 부족한 경우 다음 배치에서 차감됨
- [ ] 차감 후 qty_on_hand가 0이 되는 경우 정상 처리

---

## 6. 산출물

### 6.1 완료된 기능
- ✅ 재고 조회 UI (지사별, 제품별, 배치별)
- ✅ 유통기한 경고 배지 시스템
- ✅ HQ → 지사 이전 UI
- ✅ **FIFO 로직 구현** (유통기한 순서대로 출고)
- ✅ 재고 이전 트랜잭션 처리
- ✅ 역할별 재고 조회 권한 제어

### 6.2 다음 Phase 준비사항
- Phase 05에서 환율 관리 구현 (수동 입력)
- Phase 06에서 가격 계산 엔진 구현 (이전 비용 + 환율 + 마진)

---

## 7. 참고 자료

- [FIFO Inventory Management](https://en.wikipedia.org/wiki/FIFO_and_LIFO_accounting)
- [PostgreSQL Functions](https://www.postgresql.org/docs/current/sql-createfunction.html)
- [Supabase RPC](https://supabase.com/docs/guides/database/functions)

---

## 8. 작업 이후 체크리스트

- [ ] 재고 조회 UI 정상 작동 확인
- [ ] FIFO 로직 테스트 완료
- [ ] HQ → 지사 이전 전체 프로세스 검증
- [ ] 재고 수량 정확성 검증
- [ ] GitHub에 코드 푸시
- [ ] Worklog 문서 작성: `004.phase04.재고_관리_및_HQ_지사_이전.md`
- [ ] Phase 05 계획 검토
