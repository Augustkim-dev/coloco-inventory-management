# Phase 07: 판매 입력 및 FIFO 재고 차감

**작업 기간**: 1주 (5일)
**담당자**: 개발팀
**목표**: 지사 판매 입력, 자동 가격 적용, FIFO 재고 차감 구현

---

## 1. 개요

지사 Branch Manager가 일일 판매를 입력하는 기능을 구현합니다. 판매 입력 시 pricing_configs에서 설정된 가격을 자동으로 불러오고, FIFO 로직으로 재고를 차감합니다.

### 핵심 목표
- ✅ 판매 입력 UI (Branch Manager 전용)
- ✅ pricing_configs에서 자동 가격 불러오기
- ✅ **FIFO 재고 차감** (유통기한 순서대로)
- ✅ 판매 이력 조회
- ✅ 재고 부족 시 에러 처리

---

## 2. 비즈니스 워크플로우

### 2.1 전체 프로세스

```
1. Branch Manager 로그인
   - 자동으로 자기 지사 할당됨
   ↓
2. 판매 입력
   - 판매 날짜 선택
   - 제품 선택
   - 수량 입력
   ↓
3. 가격 자동 적용
   - pricing_configs에서 해당 제품-지사의 final_price 조회
   - 단가 자동 입력
   ↓
4. FIFO 재고 차감
   - 지사 stock_batches에서 가장 빠른 expiry_date 조회
   - 순차적으로 재고 차감
   ↓
5. 판매 기록 저장
   - sales 테이블에 저장
   ↓
6. 완료
   - 지사 재고 감소
   - 판매 이력 조회 가능
```

---

## 3. 작업 상세

### 3.1 판매 입력 UI

#### 3.1.1 판매 목록 페이지

**파일**: `app/(dashboard)/sales/page.tsx`

```typescript
import { createServerClient } from '@/lib/supabase/server'
import { SalesList } from '@/components/sales/sales-list'
import { Button } from '@/components/ui/button'
import Link from 'next/link'
import { Plus } from 'lucide-react'

export default async function SalesPage() {
  const supabase = createServerClient()

  // 현재 사용자 정보 조회
  const { data: { user } } = await supabase.auth.getUser()
  const { data: profile } = await supabase
    .from('users')
    .select('role, location_id')
    .eq('id', user?.id)
    .single()

  // 판매 내역 조회 (역할별 필터링)
  let query = supabase
    .from('sales')
    .select(`
      *,
      product:products(sku, name, unit),
      location:locations(name, currency)
    `)
    .order('sale_date', { ascending: false })
    .order('created_at', { ascending: false })

  // Branch Manager는 자기 지사만 조회
  if (profile?.role === 'Branch_Manager') {
    query = query.eq('location_id', profile.location_id)
  }

  const { data: sales, error } = await query

  if (error) {
    return <div>Error loading sales: {error.message}</div>
  }

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold">Sales</h1>
        {profile?.role === 'Branch_Manager' && (
          <Link href="/sales/new">
            <Button>
              <Plus className="mr-2 h-4 w-4" />
              Add Sale
            </Button>
          </Link>
        )}
      </div>

      <SalesList sales={sales || []} />
    </div>
  )
}
```

#### 3.1.2 판매 목록 컴포넌트

**파일**: `components/sales/sales-list.tsx`

```typescript
'use client'

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table'
import { formatDate, formatCurrency } from '@/lib/utils'

export function SalesList({ sales }: { sales: any[] }) {
  // 날짜별로 그룹화
  const groupedSales = sales.reduce((acc, sale) => {
    const date = sale.sale_date
    if (!acc[date]) {
      acc[date] = []
    }
    acc[date].push(sale)
    return acc
  }, {} as Record<string, any[]>)

  return (
    <div className="space-y-6">
      {Object.entries(groupedSales).map(([date, salesOnDate]) => {
        const totalAmount = salesOnDate.reduce((sum, sale) => sum + parseFloat(sale.total_amount), 0)
        const currency = salesOnDate[0]?.currency

        return (
          <div key={date}>
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-semibold">{formatDate(date)}</h2>
              <div className="text-lg font-bold">
                Total: {formatCurrency(totalAmount, currency)}
              </div>
            </div>
            <div className="border rounded-lg">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Product</TableHead>
                    <TableHead>Location</TableHead>
                    <TableHead>Quantity</TableHead>
                    <TableHead>Unit Price</TableHead>
                    <TableHead>Total Amount</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {salesOnDate.map((sale) => (
                    <TableRow key={sale.id}>
                      <TableCell>
                        <div>
                          <div className="font-medium">{sale.product.sku}</div>
                          <div className="text-sm text-gray-500">{sale.product.name}</div>
                        </div>
                      </TableCell>
                      <TableCell>{sale.location.name}</TableCell>
                      <TableCell>
                        {sale.qty} {sale.product.unit}
                      </TableCell>
                      <TableCell>{formatCurrency(sale.unit_price, sale.currency)}</TableCell>
                      <TableCell className="font-bold">
                        {formatCurrency(sale.total_amount, sale.currency)}
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </div>
          </div>
        )
      })}
    </div>
  )
}
```

#### 3.1.3 판매 입력 페이지

**파일**: `app/(dashboard)/sales/new/page.tsx`

```typescript
import { createServerClient } from '@/lib/supabase/server'
import { SaleForm } from '@/components/sales/sale-form'
import { redirect } from 'next/navigation'

export default async function NewSalePage() {
  const supabase = createServerClient()

  // 현재 사용자 정보 조회
  const { data: { user } } = await supabase.auth.getUser()
  const { data: profile } = await supabase
    .from('users')
    .select('role, location_id, location:locations(*)')
    .eq('id', user?.id)
    .single()

  // Branch Manager만 접근 가능
  if (profile?.role !== 'Branch_Manager') {
    redirect('/dashboard')
  }

  // 제품 목록 조회
  const { data: products } = await supabase
    .from('products')
    .select('id, sku, name, unit')
    .order('sku')

  return (
    <div>
      <h1 className="text-3xl font-bold mb-6">Add Sale</h1>
      <SaleForm
        location={profile.location}
        products={products || []}
      />
    </div>
  )
}
```

#### 3.1.4 판매 입력 폼

**파일**: `components/sales/sale-form.tsx`

```typescript
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { createClient } from '@/lib/supabase/client'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { useToast } from '@/components/ui/use-toast'
import { formatCurrency } from '@/lib/utils'

interface SaleFormProps {
  location: any
  products: Array<{ id: string; sku: string; name: string; unit: string }>
}

export function SaleForm({ location, products }: SaleFormProps) {
  const [formData, setFormData] = useState({
    product_id: '',
    qty: 1,
    sale_date: new Date().toISOString().split('T')[0],
  })
  const [pricing, setPricing] = useState<{ unit_price: number; available_stock: number } | null>(null)
  const [loading, setLoading] = useState(false)
  const router = useRouter()
  const { toast } = useToast()
  const supabase = createClient()

  // 제품 선택 시 가격 및 재고 조회
  const handleProductChange = async (productId: string) => {
    setFormData({ ...formData, product_id: productId })

    // 가격 조회
    const { data: priceData } = await supabase
      .from('pricing_configs')
      .select('final_price')
      .eq('product_id', productId)
      .eq('to_location_id', location.id)
      .single()

    // 재고 조회
    const { data: stockData } = await supabase
      .rpc('get_available_stock', {
        p_location_id: location.id,
        p_product_id: productId,
      })

    if (priceData && stockData !== null) {
      setPricing({
        unit_price: priceData.final_price,
        available_stock: stockData,
      })
    } else {
      setPricing(null)
      toast({
        variant: 'destructive',
        title: 'No pricing configuration found',
        description: 'Please contact HQ Admin to set up pricing for this product.',
      })
    }
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    if (!formData.product_id || !pricing) {
      toast({ variant: 'destructive', title: 'Please select a product' })
      return
    }

    if (formData.qty <= 0) {
      toast({ variant: 'destructive', title: 'Quantity must be greater than 0' })
      return
    }

    if (formData.qty > pricing.available_stock) {
      toast({
        variant: 'destructive',
        title: 'Insufficient stock',
        description: `Available: ${pricing.available_stock} units`,
      })
      return
    }

    setLoading(true)

    try {
      const response = await fetch('/api/sales', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          location_id: location.id,
          product_id: formData.product_id,
          qty: formData.qty,
          unit_price: pricing.unit_price,
          currency: location.currency,
          sale_date: formData.sale_date,
        }),
      })

      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || 'Failed to add sale')
      }

      toast({ title: 'Sale added successfully' })
      router.push('/sales')
      router.refresh()
    } catch (error: any) {
      toast({
        variant: 'destructive',
        title: 'Error',
        description: error.message,
      })
    } finally {
      setLoading(false)
    }
  }

  const totalAmount = pricing ? formData.qty * pricing.unit_price : 0

  return (
    <Card>
      <CardHeader>
        <CardTitle>Add Sale - {location.name}</CardTitle>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <Label htmlFor="sale_date">Sale Date *</Label>
            <Input
              id="sale_date"
              type="date"
              value={formData.sale_date}
              onChange={(e) => setFormData({ ...formData, sale_date: e.target.value })}
              max={new Date().toISOString().split('T')[0]}
              required
            />
          </div>

          <div>
            <Label htmlFor="product_id">Product *</Label>
            <Select
              value={formData.product_id}
              onValueChange={handleProductChange}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select product" />
              </SelectTrigger>
              <SelectContent>
                {products.map((product) => (
                  <SelectItem key={product.id} value={product.id}>
                    {product.sku} - {product.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            {pricing && (
              <p className="text-sm text-gray-600 mt-1">
                Available stock: {pricing.available_stock} units
              </p>
            )}
          </div>

          <div>
            <Label htmlFor="qty">Quantity *</Label>
            <Input
              id="qty"
              type="number"
              min="1"
              max={pricing?.available_stock || undefined}
              value={formData.qty}
              onChange={(e) => setFormData({ ...formData, qty: parseInt(e.target.value) })}
              disabled={!pricing}
              required
            />
          </div>

          {pricing && (
            <div className="p-4 bg-green-50 rounded-lg space-y-2">
              <div className="flex justify-between">
                <span>Unit Price:</span>
                <span className="font-bold">{formatCurrency(pricing.unit_price, location.currency)}</span>
              </div>
              <div className="flex justify-between">
                <span>Quantity:</span>
                <span className="font-bold">{formData.qty}</span>
              </div>
              <div className="flex justify-between text-lg">
                <span>Total Amount:</span>
                <span className="font-bold">{formatCurrency(totalAmount, location.currency)}</span>
              </div>
            </div>
          )}

          <div className="flex gap-2">
            <Button type="submit" disabled={loading || !pricing}>
              {loading ? 'Adding...' : 'Add Sale'}
            </Button>
            <Button type="button" variant="outline" onClick={() => router.back()}>
              Cancel
            </Button>
          </div>
        </form>
      </CardContent>
    </Card>
  )
}
```

---

### 3.2 판매 API Route (FIFO 재고 차감 포함)

**파일**: `app/api/sales/route.ts`

```typescript
import { createServerClient } from '@/lib/supabase/server'
import { NextResponse } from 'next/server'

export async function POST(request: Request) {
  const supabase = createServerClient()

  const { location_id, product_id, qty, unit_price, currency, sale_date } = await request.json()

  try {
    // 현재 사용자 조회
    const { data: { user } } = await supabase.auth.getUser()

    // 1. FIFO로 지사 재고 조회 (유통기한 빠른 순)
    const { data: batches, error: fetchError } = await supabase
      .from('stock_batches')
      .select('*')
      .eq('location_id', location_id)
      .eq('product_id', product_id)
      .eq('quality_status', 'OK')
      .gt('qty_on_hand', 0)
      .order('expiry_date', { ascending: true })

    if (fetchError) throw fetchError

    if (!batches || batches.length === 0) {
      return NextResponse.json({ error: 'No stock available' }, { status: 400 })
    }

    // 2. FIFO 로직: 순차적으로 차감
    let remainingQty = qty
    const deductions: Array<{ batch_id: string; deduct_qty: number }> = []

    for (const batch of batches) {
      if (remainingQty <= 0) break

      const deductQty = Math.min(batch.qty_on_hand, remainingQty)

      deductions.push({
        batch_id: batch.id,
        deduct_qty: deductQty,
      })

      remainingQty -= deductQty
    }

    // 3. 재고 부족 체크
    if (remainingQty > 0) {
      return NextResponse.json(
        { error: `Insufficient stock. Short by ${remainingQty} units.` },
        { status: 400 }
      )
    }

    // 4. 재고 차감
    for (const deduction of deductions) {
      const { error: updateError } = await supabase
        .from('stock_batches')
        .update({
          qty_on_hand: supabase.raw(`qty_on_hand - ${deduction.deduct_qty}`),
        })
        .eq('id', deduction.batch_id)

      if (updateError) throw updateError
    }

    // 5. 판매 기록 저장
    const { error: saleError } = await supabase
      .from('sales')
      .insert([{
        location_id,
        product_id,
        sale_date,
        qty,
        unit_price,
        currency,
        created_by: user?.id,
      }])

    if (saleError) throw saleError

    return NextResponse.json({ success: true, deductions })
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}
```

---

## 4. 테스트 체크리스트

### 4.1 판매 입력 테스트
- [ ] Branch Manager만 판매 입력 가능
- [ ] 제품 선택 시 가격 자동 불러오기
- [ ] 제품 선택 시 사용 가능한 재고 표시
- [ ] 총액 자동 계산
- [ ] 재고 부족 시 에러 메시지

### 4.2 FIFO 재고 차감 테스트
- [ ] 유통기한이 가장 빠른 배치부터 차감됨
- [ ] 하나의 배치로 부족한 경우 다음 배치에서 차감됨
- [ ] 차감 후 qty_on_hand가 정확함
- [ ] 재고 0이 된 배치는 더 이상 판매에 사용되지 않음

### 4.3 판매 이력 테스트
- [ ] HQ Admin은 모든 지사 판매 조회 가능
- [ ] Branch Manager는 자기 지사 판매만 조회 가능
- [ ] 날짜별로 그룹화 표시
- [ ] 일별 총액 표시

### 4.4 통합 테스트
- [ ] 판매 입력 → 재고 차감 → 판매 이력 조회 전체 프로세스 정상 작동
- [ ] 재고 수량 정확성 검증
- [ ] 가격 자동 적용 정확성 검증

---

## 5. 산출물

### 5.1 완료된 기능
- ✅ 판매 입력 UI (Branch Manager 전용)
- ✅ pricing_configs에서 자동 가격 불러오기
- ✅ **FIFO 재고 차감 구현** (유통기한 순서대로)
- ✅ 판매 이력 조회 (날짜별 그룹화)
- ✅ 재고 부족 시 에러 처리
- ✅ 역할별 판매 조회 권한 제어

### 5.2 다음 Phase 준비사항
- Phase 08에서 대시보드 및 리포트 구현
- 판매 테스트 데이터 생성 (각 지사별 10-20건)

---

## 6. 작업 이후 체크리스트

- [ ] 판매 입력 UI 정상 작동 확인
- [ ] FIFO 재고 차감 로직 검증
- [ ] 판매 이력 조회 정상 작동 확인
- [ ] 재고 및 판매 수량 정확성 검증
- [ ] GitHub에 코드 푸시
- [ ] Worklog 문서 작성: `007.phase07.판매_입력_및_FIFO_재고_차감.md`
- [ ] Phase 08 계획 검토
