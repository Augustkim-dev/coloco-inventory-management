# Phase 03-1 Worklog: PO 생성 시 Supplier별 제품 필터링 구현

**작업 일자**: 2025-10-29
**작업자**: 개발팀
**목표**: Purchase Order 생성 시 선택된 supplier의 제품만 필터링하여 표시
**상태**: ✅ 완료

---

## 작업 개요

Phase 03 기본 구현 이후, PO 생성 화면에서 모든 제품이 표시되는 문제를 해결했습니다. `supplier_products` 테이블을 활용하여 선택된 supplier가 공급하는 제품만 필터링하고, 제품 선택 시 가격과 MOQ를 자동으로 입력하는 기능을 추가했습니다.

---

## 발견된 문제

### 1. 제품 필터링 미적용
**증상**:
- PO 생성 화면에서 supplier를 선택해도 전체 제품 목록이 표시됨
- 선택된 supplier가 공급하지 않는 제품까지 선택 가능

**원인**:
- `page.tsx`에서 `products` 테이블만 조회
- `supplier_products` 관계 테이블을 활용하지 않음
- 프론트엔드에서 필터링 로직 없음

### 2. Generated Column 삽입 오류
**증상**:
```
Error: cannot insert a non-DEFAULT value into column "total_price"
```

**원인**:
- `purchase_order_items.total_price`가 `GENERATED ALWAYS AS (qty * unit_price) STORED`로 정의됨
- POForm에서 `total_price` 값을 직접 삽입 시도
- PostgreSQL의 Generated Column은 자동 계산되므로 명시적 삽입 불가

---

## 구현된 기능

### 1. Supplier-Product 관계 조회

#### 1.1 Page.tsx 수정
**파일**: `app/(dashboard)/purchase-orders/new/page.tsx`

**수정 내용**:
```typescript
// Before: 모든 제품 조회
const { data: products } = await supabase
  .from('products')
  .select('id, sku, name, unit')
  .order('sku')

// After: supplier_products 테이블 조인
const { data: supplierProducts } = await supabase
  .from('supplier_products')
  .select(`
    supplier_id,
    product_id,
    unit_price,
    lead_time_days,
    minimum_order_qty,
    is_primary_supplier,
    products (
      id,
      sku,
      name,
      unit
    )
  `)
  .eq('is_active', true)
  .order('supplier_id')
```

**개선 사항**:
- Supplier별 제품 정보와 함께 가격, MOQ, 리드타임 조회
- `is_active = true` 필터링으로 활성 공급 관계만 조회
- 제품 정보를 nested object로 조회 (Supabase foreign key 활용)

---

### 2. POForm 컴포넌트 개선

#### 2.1 타입 정의 추가
**파일**: `components/purchase-orders/po-form.tsx`

```typescript
interface SupplierProduct {
  supplier_id: string
  product_id: string
  unit_price: number
  lead_time_days: number
  minimum_order_qty: number
  is_primary_supplier: boolean
  products: {
    id: string
    sku: string
    name: string
    unit: string
  }
}

interface POFormProps {
  suppliers: Array<{ id: string; name: string }>
  supplierProducts: SupplierProduct[]  // products → supplierProducts
  mode: 'create' | 'edit'
}
```

#### 2.2 제품 필터링 로직
```typescript
// 선택된 supplier의 제품만 필터링
const getAvailableProducts = () => {
  if (!formData.supplier_id) {
    return []
  }
  return supplierProducts
    .filter((sp) => sp.supplier_id === formData.supplier_id)
    .map((sp) => ({
      id: sp.products.id,
      sku: sp.products.sku,
      name: sp.products.name,
      unit: sp.products.unit,
      unit_price: sp.unit_price,
      minimum_order_qty: sp.minimum_order_qty,
    }))
}

const availableProducts = getAvailableProducts()
```

**로직 설명**:
1. `supplier_id`가 선택되지 않으면 빈 배열 반환 → 제품 선택 불가
2. 선택된 supplier의 제품만 필터링
3. 제품 정보와 함께 `unit_price`, `minimum_order_qty` 포함

#### 2.3 Supplier 변경 시 초기화
```typescript
const handleSupplierChange = (supplierId: string) => {
  setFormData({ ...formData, supplier_id: supplierId })
  // 기존 아이템 초기화
  setItems([{ product_id: '', qty: 1, unit_price: 0 }])
}
```

**개선 사항**:
- Supplier 변경 시 이전에 추가한 items 초기화
- 잘못된 supplier-product 조합 방지

#### 2.4 제품 선택 시 자동 입력
```typescript
const updateItem = (index: number, field: keyof POItem, value: any) => {
  const newItems = [...items]
  newItems[index] = { ...newItems[index], [field]: value }

  // 제품 선택 시 자동으로 단가 입력
  if (field === 'product_id' && value) {
    const supplierProduct = supplierProducts.find(
      (sp) => sp.supplier_id === formData.supplier_id && sp.products.id === value
    )
    if (supplierProduct) {
      newItems[index].unit_price = supplierProduct.unit_price
      // MOQ 이상으로 수량 설정
      if (newItems[index].qty < supplierProduct.minimum_order_qty) {
        newItems[index].qty = supplierProduct.minimum_order_qty
      }
    }
  }

  setItems(newItems)
}
```

**자동화 기능**:
1. 제품 선택 시 해당 supplier의 `unit_price` 자동 입력
2. 현재 수량이 MOQ보다 적으면 MOQ로 자동 조정
3. 수동 수정 가능 (필요시 override)

---

### 3. UI/UX 개선

#### 3.1 Supplier 선택 영역
```tsx
<Select value={formData.supplier_id} onValueChange={handleSupplierChange}>
  <SelectTrigger>
    <SelectValue placeholder="Select supplier" />
  </SelectTrigger>
  <SelectContent>
    {suppliers.map((supplier) => (
      <SelectItem key={supplier.id} value={supplier.id}>
        {supplier.name}
      </SelectItem>
    ))}
  </SelectContent>
</Select>
{formData.supplier_id && (
  <p className="text-sm text-muted-foreground mt-1">
    {availableProducts.length} products available from this supplier
  </p>
)}
```

**개선 사항**:
- Supplier 선택 후 이용 가능한 제품 수 표시
- 사용자에게 시각적 피드백 제공

#### 3.2 제품 선택 드롭다운
```tsx
<Select
  value={item.product_id}
  onValueChange={(value) => updateItem(index, 'product_id', value)}
  disabled={!formData.supplier_id}  // Supplier 선택 전 비활성화
>
  <SelectTrigger>
    <SelectValue
      placeholder={
        formData.supplier_id
          ? 'Select product'
          : 'Select supplier first'  // 안내 메시지
      }
    />
  </SelectTrigger>
  <SelectContent>
    {availableProducts.map((product) => (
      <SelectItem key={product.id} value={product.id}>
        {product.sku} - {product.name} ({product.unit}) - MOQ: {product.minimum_order_qty}
      </SelectItem>
    ))}
  </SelectContent>
</Select>
```

**UX 개선**:
1. Supplier 선택 전에는 제품 드롭다운 비활성화
2. Placeholder로 "Select supplier first" 안내
3. 각 제품에 MOQ 정보 표시
4. SKU, 이름, 단위 모두 표시하여 식별 용이

---

### 4. Generated Column 이슈 해결

#### 4.1 문제의 원인
**스키마 정의** (`006_create_purchase_orders_tables.sql`):
```sql
CREATE TABLE public.purchase_order_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  po_id UUID NOT NULL REFERENCES public.purchase_orders(id) ON DELETE CASCADE,
  product_id UUID NOT NULL REFERENCES public.products(id) ON DELETE RESTRICT,
  qty INTEGER NOT NULL CHECK (qty > 0),
  unit_price DECIMAL(12, 2) NOT NULL CHECK (unit_price >= 0),
  total_price DECIMAL(15, 2) GENERATED ALWAYS AS (qty * unit_price) STORED,  -- 자동 계산
  ...
);
```

`total_price`는 **Generated Column**으로 PostgreSQL이 자동으로 `qty * unit_price`를 계산하여 저장합니다.

#### 4.2 해결 방법
```typescript
// Before: total_price 직접 삽입 시도 (에러 발생)
const { error: itemsError } = await supabase.from('purchase_order_items').insert(
  items.map((item) => ({
    po_id: po.id,
    product_id: item.product_id,
    qty: item.qty,
    unit_price: item.unit_price,
    total_price: item.qty * item.unit_price,  // ❌ 에러!
  }))
)

// After: total_price 제외 (데이터베이스가 자동 계산)
const { error: itemsError } = await supabase.from('purchase_order_items').insert(
  items.map((item) => ({
    po_id: po.id,
    product_id: item.product_id,
    qty: item.qty,
    unit_price: item.unit_price,
    // total_price는 DB가 자동 계산 ✅
  }))
)
```

**참고 사항**:
- Generated Column은 `INSERT`, `UPDATE` 시 값을 제공하면 안 됨
- `SELECT` 시에는 자동으로 계산된 값이 반환됨
- Storage는 `STORED` (물리적 저장) vs `VIRTUAL` (조회 시 계산)

---

## 데이터베이스 관계 활용

### supplier_products 테이블의 역할

```
┌─────────────┐         ┌──────────────────┐         ┌──────────┐
│  suppliers  │────1:N──│ supplier_products│───N:1───│ products │
└─────────────┘         └──────────────────┘         └──────────┘
```

**Many-to-Many 관계**:
- 한 supplier는 여러 products 공급 가능
- 한 product는 여러 suppliers에서 공급 가능 (대체 공급업체)

**Junction Table 주요 필드**:
- `supplier_id` + `product_id`: 관계 정의
- `unit_price`: Supplier별 제품 가격
- `minimum_order_qty`: Supplier별 MOQ
- `lead_time_days`: Supplier별 리드타임
- `is_primary_supplier`: 우선 공급업체 여부
- `is_active`: 현재 공급 가능 여부

**예시 데이터**:
```
Seoul Beauty (Supplier) → 7개 스킨케어 제품 공급
  - SKN-HYA-SRM-100: 25,000 KRW, MOQ 100
  - SKN-VTC-CRM-50: 35,000 KRW, MOQ 100

Jeju Natural (Supplier) → 4개 자연/바디 제품 공급
  - SKN-GRN-CLN-150: 13,000 KRW, MOQ 50 (대체 공급업체)
  - BDY-LOT-CHR-300: 16,000 KRW, MOQ 50 (주 공급업체)
```

---

## 테스트 시나리오

### 1. Supplier 선택 전
- ✅ 제품 드롭다운 비활성화 확인
- ✅ "Select supplier first" 메시지 표시 확인

### 2. Supplier 선택 후 (Seoul Beauty)
- ✅ 7개 스킨케어 제품만 표시 확인
- ✅ "7 products available from this supplier" 메시지 확인
- ✅ 다른 supplier의 제품은 목록에 없음 확인

### 3. 제품 선택 시
- ✅ Unit price 자동 입력 확인
- ✅ Quantity가 MOQ보다 적으면 자동 조정 확인
- ✅ 수동으로 가격/수량 수정 가능 확인

### 4. Supplier 변경 시
- ✅ 기존 추가한 items 초기화 확인
- ✅ 새로운 supplier의 제품만 표시 확인

### 5. PO 생성
- ✅ total_price 에러 없이 정상 생성 확인
- ✅ 데이터베이스에 total_price 자동 계산되어 저장 확인

---

## 기술적 개선 사항

### 1. Type Safety
- `SupplierProduct` 인터페이스 정의로 타입 안전성 확보
- Nested object 타입 정확히 정의

### 2. Data Fetching 최적화
- Supabase foreign key join 활용
- N+1 쿼리 문제 방지
- Single query로 모든 필요한 데이터 조회

### 3. UX 개선
- Progressive disclosure (단계별 정보 제공)
- Disabled state로 잘못된 입력 방지
- 자동 입력으로 데이터 입력 편의성 향상

### 4. Error Prevention
- Generated Column 이해 및 올바른 활용
- Foreign key 제약으로 데이터 무결성 보장

---

## 학습 내용

### 1. PostgreSQL Generated Columns
- `GENERATED ALWAYS AS (expression) STORED`
- Insert/Update 시 값 제공 불가
- 자동 계산되어 물리적으로 저장됨
- Index 생성 가능 (STORED인 경우)

### 2. Supabase Nested Queries
```typescript
.select(`
  field1,
  field2,
  related_table (
    column1,
    column2
  )
`)
```
- Foreign key 기반 자동 조인
- 깔끔한 nested object 반환

### 3. Many-to-Many 관계 활용
- Junction table의 추가 필드 (unit_price, MOQ 등)
- 관계 자체가 의미 있는 데이터 보유

---

## 다음 단계 (향후 개선 사항)

### 1. 대체 공급업체 표시
- 제품 선택 시 다른 supplier의 가격 비교 표시
- `is_primary_supplier` 플래그 활용

### 2. 리드타임 표시
- 예상 입고일 자동 계산
- `order_date + lead_time_days`

### 3. 재고 확인 연동
- 제품 선택 시 현재 HQ 재고 수량 표시
- 발주 추천 수량 제안

### 4. Price History
- Supplier별 가격 변동 이력 추적
- 가격 인상/인하 알림

---

## 파일 변경 이력

### 수정된 파일
1. `app/(dashboard)/purchase-orders/new/page.tsx`
   - `supplierProducts` 조회 로직 추가
   - Props 변경

2. `components/purchase-orders/po-form.tsx`
   - `SupplierProduct` 타입 정의
   - `getAvailableProducts()` 함수 추가
   - `handleSupplierChange()` 함수 추가
   - `updateItem()` 자동 입력 로직 추가
   - UI 개선 (placeholder, disabled, MOQ 표시)
   - `total_price` 삽입 제거

3. `CLAUDE.md`
   - `supplier_products` 관계 설명 추가
   - API 엔드포인트 문서화

---

## Git Commit

```bash
git add app/(dashboard)/purchase-orders/new/page.tsx
git add components/purchase-orders/po-form.tsx
git add CLAUDE.md
git commit -m "Fix: PO 생성 시 supplier별 제품 필터링 및 자동 가격 입력 구현"
git push origin master
```

**Commit Hash**: `ae457a4`

---

## 결론

이번 작업을 통해 Purchase Order 생성 워크플로우가 크게 개선되었습니다:

1. **데이터 무결성**: Supplier가 실제로 공급하는 제품만 선택 가능
2. **사용자 편의성**: 가격과 MOQ 자동 입력으로 수작업 최소화
3. **오류 방지**: Generated Column 올바른 이해 및 활용
4. **타입 안전성**: TypeScript 타입 정의로 런타임 오류 방지

Phase 03의 핵심 기능이 완성되었으며, 다음 단계인 PO 승인 및 HQ 입고 처리로 진행할 준비가 완료되었습니다.
